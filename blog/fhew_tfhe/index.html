<!doctype html><html lang="en" class="min-h-full antialiased"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A primer on the FHEW &amp; TFHE schemes | Privacy Preserving Systems Lab</title><meta name="description" content="Fully Homomorphic Encryption (FHE) is a cryptographic primitive that allows one to perform computations on encrypted data. The big efficiency improvements achieved in this primitive in the last few years have fostered the design and development of many privacy-enhancing technologies."><meta name="robots" content="index,follow"><link rel="preload" href="fonts/gillsans/Gill_Sans_Medium.otf"><link rel="preload" href="fonts/sourceserifpro/source-serif-pro-400-normal.woff"><link rel="preload" href="fonts/sourceserifpro/source-serif-pro-400-italic.woff"><link rel="stylesheet" href="/css/main.min.css"><script src="/js/main.min.js" defer="defer"></script><meta itemprop="name" content="A primer on the FHEW &amp; TFHE schemes | Privacy Preserving Systems Lab"><meta itemprop="description" content="Fully Homomorphic Encryption (FHE) is a cryptographic primitive that allows one to perform computations on encrypted data. The big efficiency improvements achieved in this primitive in the last few years have fostered the design and development of many privacy-enhancing technologies."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="A primer on the FHEW &amp; TFHE schemes | Privacy Preserving Systems Lab"><meta name="twitter:description" content="Fully Homomorphic Encryption (FHE) is a cryptographic primitive that allows one to perform computations on encrypted data. The big efficiency improvements achieved in this primitive in the last few years have fostered the design and development of many privacy-enhancing technologies."><meta name="twitter:site" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content="https://pps-lab.com"><meta name="og:title" content="A primer on the FHEW &amp; TFHE schemes | Privacy Preserving Systems Lab"><meta name="og:description" content="Fully Homomorphic Encryption (FHE) is a cryptographic primitive that allows one to perform computations on encrypted data. The big efficiency improvements achieved in this primitive in the last few years have fostered the design and development of many privacy-enhancing technologies."><meta name="og:image" content="https://pps-lab.com"><meta name="og:url" content="https://pps-lab.com/blog/fhew_tfhe/"><meta name="og:site_name" content="Privacy Preserving Systems Lab"><meta name="og:locale" content="en_GB"><meta name="og:type" content="website"><link rel="icon" type="image/png" href="/images/favicon/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="manifest" href="/images/favicon/site.webmanifest"><link rel="canonical" href="https://pps-lab.com/blog/fhew_tfhe/"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-4ZPP8W4RNN"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-4ZPP8W4RNN');</script></head><body id="blog" class="leading-normal bg-white dark:bg-black"><a class="sr-only" href="#main">Skip to content</a><div id="wrapper" class="wrapper pb-16 md:pb-0 flex flex-col relative min-h-screen"><div class=""><header id="header" class="inner header flex flex-col md:flex-row md:justify-start items-center p-2 md:p-4"><a class="company-logo-link block hover:text-link-hover" href="/" title="Privacy Preserving Systems Lab home"><div></div></a><nav id="nav" class="nav hidden md:flex flex-grow"><ul class="menu list-reset text-base flex flex-row justify-between flex-grow"><div class="flex flex-col md:flex-row items-center"><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/" class="link text-black">Home</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/people/" class="link text-black">People</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/research/" class="link text-black">Research</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/publications/" class="link text-black">Publications</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/teaching/" class="link text-black">Teaching</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/funding/" class="link text-black">Funding</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/blog/" class="link text-black">Blog</a></li></div><li class="level-1 mb-4 md:mb-0"><a href="https://github.com/pps-lab" rel="noopener" aria-label="Github" target="_blank" class="link text-black"><svg class="fill-current" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22" height="22" viewBox="0 0 22 22"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg></a></li></ul></nav></header></div><main id="main" class="main inner flex flex-1 flex-col py-10 lg:py-20 focus:outline-none text-lg" tabindex="-1"><article id="container-centre" class="column centre flex-1"><div class="blog-container"><header><h1 class="page-title font-title text-3xl">A primer on the FHEW &amp; TFHE schemes</h1></header><div class="flex mb-8"><div><img class="h-16 object-center w-16 rounded-full m-auto object-cover" src="/images/people/students/Christian_Knabenhans.png" alt="Christian Knabenhans"></div><div class="flex flex-col ml-4 mt-1 text-gray-600"><div><a href="https://cknabs.github.io/" target="_blank" rel="noopener"><span>Christian Knabenhans</span></a></div><div class="flex flex-row mt">Published on&nbsp; <time datetime="Fri Oct 27 2023 00:00:00 GMT+0000 (Coordinated Universal Time)">27.10.2023</time><p class="px-2">—</p><div class="flex-col"><a href="https://github.com/zkFHE/circomlib-fhe" rel="noopener" aria-label="Github circomlib-FHE" target="_blank" style="display: inline-flex;"><svg style="margin-top: -2px;" class="fill-current" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22" height="22" viewBox="0 0 22 22"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg> <span class="ml-2">circomlib-FHE</span></a></div></div></div></div><div class="content post leading-relaxed md-content-blog"><p><em>This blog post is part of a series about our project on integrity protection for fully homomorphic encryption using zero-knowledge proofs, and was written by <a href="https://amerigal.github.io/">Antonio Merino Gallardo</a> as part as a semester project in the PPS Lab.</em></p><p><em>Next post in this series: <a href="/blog/fhe_arithmetization/">Arithmetizing FHE in circom</a></em></p><h2>Fully Homomorphic Encryption: FHEW &amp; TFHE</h2><p>Fully Homomorphic Encryption (FHE) is a cryptographic primitive that allows one to perform computations on encrypted data. The big efficiency improvements achieved in this primitive in the last few years have fostered the design and development of many privacy-enhancing technologies.</p><p>The security of most FHE constructions relies on the introduction of some small random noise into the ciphertexts. While that noise is meant to make it infeasible for attackers to decrypt without knowing the key, it also raises some issues. The noise increases when performing computations and ciphertexts can only withstand a certain amount of noise before they become useless. In 2009, Gentry solved this problem by introducing the so-called bootstrapping procedure that lowers the noise of a ciphertext without having access to the decryption key, hence constructing the first fully homomorphic encryption scheme <a href="#Gen09">[Gen09]</a>.</p><p>Since Gentry's work, a variety of FHE schemes have been proposed with important efficiency improvements . As bootstrapping is one of the main bottlenecks, different approaches have been presented to deal with this costly operation, such as simultaneously refreshing the noise of many ciphertexts in the same bootstrapping or performing as many operations as possible before bootstrapping. The FHEW scheme <a href="#DM15">[DM15]</a> focuses instead on simplifying the setting and supports a fast bootstrapping procedure tailored for ciphertexts encrypting a single bit. The TFHE scheme <a href="#CGGI16">[CGGI16]</a>, <a href="#CGGI20">[CGGI20]</a> subsequently improved on it and is part of the state of the art in terms of FHE schemes for boolean and short integer operations (up to 8 bits). More recently, two new variants have been proposed in <a href="#LMK+23">[LMK+23]</a> and <a href="#XZD+23">[XZD+23]</a>.</p><p>There are several explanations of the fundamentals of FHEW and/or TFHE schemes (<a href="#DM15">[DM15]</a>, <a href="#CGGI20">[CGGI20]</a>, <a href="#MP21">[MP21]</a>, <a href="#J22">[J22]</a>, <a href="#ZAMA">[ZAMA]</a>). Implementation-wise the main references are OpenFHE's implementation of FHEW and TFHE <a href="#OpenFHE">[OpenFHE]</a>, and ZAMA's implementation of TFHE <a href="#TFHE-rs">[TFHE-rs]</a>. Despite the variety of resources, the use of different notations and levels of abstraction in the explanations and the highly optimized code of the implementations make it hard to relate them to each other. The aim of this blog post is thus to bridge the gap between theory and practice by providing a thorough yet simple description of all the operations that these schemes involve. With that in mind, our focus will not be that much on <em>why</em> they work but rather on <em>how</em> they work with descriptions close to the implementation level.</p><p>Particularly useful was the work by Daniele Micciancio and Yuri Polyakov <a href="#MP21">[MP21]</a> describing the differences between FHEW and TFHE in a unified framework. That is the framework that this post will follow. In particular, we will consider both schemes in the integer setting (instead of describing TFHE in the Torus setting), we will consider ternary secret keys for both schemes (instead of the binary keys that TFHE originally proposed but for which there is less assurance about their security) and we will describe FHEW with certain optimizations of TFHE that can be applied to both schemes.</p><h2>Functional Boostrapping - Overview</h2><p>The FHEW and TFHE schemes focus on boolean and short integer computations and stand out for their fast bootstrapping procedure. Interestingly, their bootstrapping operation not only refreshes the noise of the ciphertext but it can also be configured to compute a function at the same time. That is the reason why it is also referred to as functional bootstrapping or programmable bootstrapping.</p><p>Circuits can be generally obtained by the application of several functional bootstrapping operations. For instance, any boolean circuit can be expressed in terms of NAND gates, and a bootstrapped NAND gate can be constructed by applying a functional bootstrapping to the sum of two encrypted bits - we will see how at the end of the post. This use of the bootstrapping operation is called gate bootstrapping.</p><p>In essence, the description of the FHEW and TFHE schemes comes down to the description of their functional bootstrapping procedures. Their structure is as follows:</p><p>We can distinguish two major phases in functional bootstrapping: the accumulator phase, which deals with the more complex RLWE and RGSW ciphertexts, and the LWE phase, which deals with the simpler LWE ciphertexts.</p><p>It is also important to note that the only algorithmic difference between FHEW and TFHE is the accumulator update, also known as the blind rotation procedure. The rest of the operations are the same for both schemes.</p><p>For expository purposes, we will start by describing the simpler LWE phase before delving into the accumulator.</p><h2>LWE phase</h2><p>An important part of the functional bootstrapping only deals with LWE ciphertexts. Let's see what these ciphertexts look like and what operations are performed with them.</p><h3>LWE ciphertexts</h3><p>Given a message $m \in \mathbb{Z}_t$, an LWE encryption of $m$ under a key $s \in \mathbb{Z}_q^n$ is an LWE ciphertext of the form:</p><p>$$ (a, b) = \left(a, (a \cdot s + \tilde{m} + e)\mod q \right) \in \mathbb{Z}_q^{n} \times \mathbb{Z}_q $$</p><p>where</p><ul><li>$\tilde{m} = (q/t)m \in \mathbb{Z}_q$ is the encoding of m</li><li>$n$ is the dimension (in practice $n \approx 512$)</li><li>$t$ is the message modulus ($t = 2$ for binary messages)</li><li>$\mathbb{Z}_t$ is the message space</li><li>$q$ is the ciphertext modulus (in practice $q = 1024$)</li><li>$s \in \mathbb{Z}_q^n$ is the key (in practice we will work with keys in the subset $\mathbb{Z}_3 ^n \cong \{-1,0,1\}^n$)</li><li>$a \leftarrow \mathbb{Z}_q^n$ is a uniformly at random sampled mask</li><li>$e \in \mathbb{Z}_q$ is a small noise or error sampled at random</li></ul><p>We define the error of a ciphertext to be $\mathrm{err}(a, b)=(b-a \cdot s-\tilde{m}) \mod q$ and will consider it to be in the centered interval $[-q/2, q/2)$. Note that for a fresh encryption we have $\mathrm{err}(a, b)=e$. We will say that $(a,b)$ is an LWE encryption of $\tilde{m}$ or $(a, b) \in \mathrm{LWE}_s^q(\tilde{m})$ as long as $|\mathrm{err}(a, b)| &lt; q/(2t)$.</p><p>Given a ciphertext $(a', b') \in \mathbb{Z}_q^{n+1}$, it is decrypted by computing:</p><p>$$ \tilde{m}' = b-a \cdot s $$</p><p>and then performing a decoding operation that corrects the error and recovers the encoded message. In this case, we would recover the message as</p><p>$$m' = \lfloor (t/q)\tilde{m} \rceil \mod t.$$</p><p>The rounding operation takes care of the small added noise. However, to correctly recover the message the noise needs to be $|\mathrm{err}(a',b')| &lt; q/(2t)$. The noise growth that occurs when performing computations with ciphertexts justifies the need for refreshing their noise with a bootstrapping procedure.</p><p>The security of this encryption scheme relies on the hardness assumption of the Learning With Errors (LWE) problem. The idea is that the value $a \cdot s + e$ acts as a one-time pad to hide the encoded message $\tilde{m}$.</p><h3>Addition &amp; Subtraction</h3><p>The LWE encryption scheme is additively homomorphic. Given two LWE ciphertexts $(a, b) \in \mathrm{LWE}_s^q(\tilde{m}), (a', b') \in \mathrm{LWE}_s^q(\tilde{m}')$ then</p><p>$$ (a'{}', b'{}') = (a, b) + (a', b') = (a + a', b + b') \in \mathbb{Z}_q^{n+1}, $$</p><p>where the sum of the masks $a + a'$ is performed component-wise, and all the sums are performed modulo $q$. We have that $\mathrm{err}(a'{}',b'{}')=\mathrm{err}(a,b)+\mathrm{err}(a',b')$, and so we will have $(a'{}', b'{}') \in \mathrm{LWE}_s^q(\tilde{m}+\tilde{m}')$ as long as $|\mathrm{err}(a,b)+\mathrm{err}(a',b')| &lt; q/(2t).$</p><p>Similarly, LWE ciphertexts can be subtracted by considering the subtraction modulo $q$.</p><h3>Modulus Switching</h3><p>The modulus switching procedure allows to change the modulus of an LWE ciphertext.</p><p>Given $(a,b) \in \mathrm{LWE}^Q_s(\tilde{m})$ encrypted with modulus $Q$ and a target modulus $q$, the following operation will be performed to all the components of the ciphertext:</p><p>$$ [x]_{Q:q} = \lfloor qx/Q \rceil $$</p><p>Overall,</p><p>$$ \mathrm{ModSwitch}(a, b) = (([a_1]_{Q:q}, \dots, [a_n]_{Q:q}), [b]_{Q:q}) \in \mathrm{LWE}^q_s(\tilde{m}). $$</p><h3>Key Switching</h3><p>The key-switching procedure allows one to change the key under which an LWE ciphertext is encrypted. This method is parametrized by a key switching modulus $Q_{ks}$ (in practice $Q_{ks} \approx 2^{14}$) and a key switching base $B_{ks}$ (in practice $B_{ks} \approx 128$). We can denote the number of digits of $Q_{ks}$ under base $B_{ks}$ as $dks = \lceil \log_{B_{ks}}Q_{ks} \rceil$.</p><p>Given an LWE ciphertext $(a,b) \in \mathrm{LWE}^{Q_{ks}}_z(\tilde{m})$ under secret key $z \in \mathbb{Z}_{Q_{ks}}^N$ and a key switching key $\mathrm{KSK}$, this operation returns an LWE ciphertext in $\mathrm{LWE}^{Q_{ks}}_s(\tilde{m})$ under secret key $s \in \mathbb{Z}_{Q_{ks}}^n$.</p><p>The key switching key is of the form $\mathrm{KSK}={\mathrm{ksk}_{i,j,v}}$ where:</p><p>$$ k_{i,j,v} \in \mathrm{LWE}^{Q_{ks}}_s(vz_iB^j_ {ks}), $$</p><p>$$ i \in \{0,\dots,N-1\}, ~ j \in \{0,\dots, dks-1 \}, ~ v \in \{0,\dots,B_{ks}-1\}. $$</p><p>Note that this method not only changes the encryption key but also the dimension of the LWE ciphertext from a dimension $N$ (in practice $N = 1024$) to a dimension $n$ (in practice $n \approx 512$).</p><p>The key switching works by decomposing under the base $B_{ks}$ each component of the mask $a$ of the input LWE ciphertext:</p><p>$$ a_i = \sum_{j=0}^{dks-1} a_{i,j}B^j_ {ks}, i \in \{0,\dots, N-1\}, a_{i,j} \in \{0,\dots,B_{ks}-1\}. $$</p><p>By obtaining the decomposition, the output of the method is:</p><p>$$ \mathrm{KeySwitch}((a,b), \mathrm{KSK}) = (\textbf{0},b) - \sum_{i,j}k_{i,j, a_{i,j}} $$</p><p>We can consider the LWE ciphertexts to be pairs of the form <code>(a[n], b)</code> and the key switching key to be a 3D array of size $N \times dks \times B_{ks}$ whose components are LWE ciphertexts.</p><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Key Switching</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span>  <span class="token punctuation">(</span>a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> KSK<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>dks<span class="token punctuation">]</span><span class="token punctuation">[</span>Bks<span class="token punctuation">]</span> of <span class="token punctuation">(</span>x<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>a'<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> b'<span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>a'<span class="token punctuation">,</span> b'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> N<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">    c <span class="token operator">:=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></span>
<span class="highlight-line">    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> dks<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">        digit <span class="token operator">:=</span> c <span class="token operator">%</span> Bks</span>
<span class="highlight-line">        key <span class="token operator">:=</span> KSK<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>digit<span class="token punctuation">]</span></span>
<span class="highlight-line">        <span class="token punctuation">(</span>a'<span class="token punctuation">,</span> b'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>a'<span class="token punctuation">,</span> b'<span class="token punctuation">)</span> <span class="token operator">-</span> key</span>
<span class="highlight-line">        c <span class="token operator">:=</span> c <span class="token operator">/</span> Bks</span>
<span class="highlight-line"><span class="token keyword">return</span> <span class="token punctuation">(</span>a'<span class="token punctuation">,</span> b'<span class="token punctuation">)</span> </span></code></pre><h2>Accumulator Phase</h2><p>The accumulator allows one to perform the core operation of the functional bootstrapping, i.e., given a function $\mathrm{f}$ and an LWE ciphertext encrypting some encoded message $\tilde{m}$, it will return an LWE ciphertext with less noise encrypting $\mathrm{f}(\tilde{m})$. That LWE ciphertext that will be extracted from the accumulator will have a different dimension, modulus, and encryption key from the input ciphertext. That is the reason why a later phase of modulus and key switching is needed. Note that the function $\mathrm{f}$ can be set to be the identity function if we just want to refresh the noise of the ciphertext.</p><p>The rough idea of the accumulator is to initialize a polynomial that stores the images of the function $\mathrm{f}$ in its coefficients. The update or blind rotation step will rotate the coefficients of the polynomial according to the given LWE ciphertext. Finally, the constant term of the polynomial will be extracted to construct the output LWE ciphertext. The part where FHEW and TFHE differ is in how they perform the update step.</p><p>In this phase, we will work with more complex ciphertexts that deal with polynomials, and that will allow us to multiply ciphertexts: Ring-LWE (RLWE) and Ring-GSW (RGSW) ciphertexts.</p><h3>RLWE ciphertexts</h3><p>The Ring-LWE (RLWE) scheme is analogous to the LWE scheme but uses polynomials instead of elements in $\mathbb{Z}_q$. We will only consider RLWE ciphertexts with one polynomial in the mask (instead of $n$ components as we did for LWE). Additionally, we will assume that messages are already encoded to the proper space.</p><p>The polynomials we will work with are elements of the cyclotomic ring $\mathcal{R} = \mathbb{Z}[X]/(X^N+1)$. As such, they can be expressed as polynomials of degree strictly less than N. Instead of working with coefficients in $\mathbb{Z}$, we will usually restrict them to $\mathbb{Z}_Q$ for some modulus $Q \in \mathbb{N}$. Hence, we will consider $\mathcal{R}_Q = \mathbb{Z}_Q[X]/(X^N+1)$. Note that we can identify $\mathcal{R}_Q$ with $\mathbb{Z}_Q^N$ and so implementation-wise we can see an element of $\mathcal{R}_Q$ as an array of $N$ components each of them storing one coefficient of the polynomial as an integer in ${0,.., Q-1}$.</p><p>Given a message $m \in \mathcal{R}_Q$, an RLWE ciphertext encrypting $m$ can be computed as:</p><p>$$ (A, B) = (A, A \cdot z + m + e) \in \mathcal{R}_Q \times \mathcal{R}_Q, $$</p><p>where</p><ul><li>$N$ is the dimension of the cyclotomic ring (in practice $N = 1024$)</li><li>$Q$ is the prime ciphertext modulus (in practice $Q \approx 2^{27}$)</li><li>$z \in \mathcal{R}_Q$ is the key (in practice we will work with keys in the &quot;subset&quot; $\{-1,0,1\}^N$)</li><li>$a \leftarrow \mathcal{R}_Q$ is a uniformly at random sampled mask (by sampling each of the N coefficients of the polynomial)</li><li>$e \in \mathcal{R}_Q$ is a small noise sampled at random</li></ul><p>We will say that $(A, B)$ is an RLWE encryption of $m$ or that $(A, B) \in \mathrm{RLWE}_z^Q(m)$ as long as the noise is within boundaries.</p><p>The decryption procedure is analogous to that of LWE and the security of the scheme is based on the Ring-Learning With Errors (RLWE) hardness assumption which is analogous to the LWE one.</p><h3>RGSW ciphertexts</h3><p>Ring-GSW (RGSW) ciphertexts are based on the work from <a href="#GSW13">[GSW13]</a> and can be seen as a collection of RLWE ciphertexts. They are parametrized by a gadget base $B_G$ (in practice $B_G \approx 128$) and we can denote the number of digits of $Q$ under base $B_G$ as $dg = \lceil \log_{B_G}(Q)\rceil$.</p><p>The RLWE encryption scheme</p><p>$$\mathrm{RLWE}_z^Q(m) \subseteq \mathcal{R}_Q \times \mathcal{R}_Q,$$</p><p>can be extended to the following RLWE' scheme</p><p>$$\mathrm{RLWE}_z^{'Q}(m) = (\mathrm{RLWE}_z^Q(m), \mathrm{RLWE}_z^Q(B_Gm), \dots, \mathrm{RLWE}_z^Q(B_G^{dg-1}m)) \subseteq (\mathcal{R}_Q^2)^{dg}$$</p><p>and finally, we can obtain the RGSW ciphertexts as</p><p>$$\mathrm{RGSW}_z^Q(m)=(\mathrm{RLWE}_z^{'Q}(-s \cdot m), \mathrm{RLWE}_z^{'Q}(m)) \subseteq ((\mathcal{R}_Q^2)^{dg})^2$$</p><h3>Initialization</h3><p>Given the second component $b \in \mathbb{Z}_q$ of an LWE ciphertext and a function $\mathrm{f}: \mathbb{Z}_q \to \mathbb{Z}_Q$, the accumulator is initialized to a noiseless encryption $(0,p) \in \mathrm{RLWE}(p)$ of the polynomial</p><p>$$ p(X) = \sum_{i=0}^{q/2} f(b-i) \cdot X^{i \cdot (2N/q)} $$</p><p>Note that the range of the input function $\mathrm{f}$ is $\mathbb{Z}_Q$, so in general we will need to rescale the values of the images when working with a function mapping $\mathbb{Z}_q \to \mathbb{Z}_q$. We will see an example of this when going over the bootstrapped NAND gate.</p><p>Regarding the factor $2N/q$ in the exponent, it comes from the fact that we are dealing with a sparse embedding of $\mathbb{Z}_Q/(X^{q/2} + 1)$ to $\mathbb{Z}_Q/(X^{N} + 1)$. For this, we need to impose that $q$ divides $2N$.</p><p>A pseudocode description of the method follows:</p><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Accumulator Initialization</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span> b<span class="token punctuation">,</span> f<span class="token punctuation">[</span>q<span class="token punctuation">]</span></span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> q<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">    B<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>N<span class="token operator">/</span>q<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">:=</span> f<span class="token punctuation">[</span><span class="token punctuation">(</span>b<span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token operator">%</span> q<span class="token punctuation">]</span></span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">return</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> </span></code></pre><p>Looking closely at the method, only half of the values of $\mathrm{f}$ are used when initializing the accumulator. This points to one important requirement of the accumulator regarding the properties of $\mathrm{f}$. In reality, we cannot use any function $\mathrm{f}: \mathbb{Z}_q \to \mathbb{Z}_Q$, but rather, one that is negacyclic, i.e., one that satisfies</p><p>$$\mathrm{f}(v + q/2) = -f(v)$$</p><p>for all $v \in \mathbb{Z}_q$. Despite this restriction, we will be able generally to adapt an arbitrary function to one that is negacyclic.</p><h3>Update</h3><p>The accumulator update or blind rotation is the core operation of the bootstrapping as well as its main bottleneck. It is a procedure that FHEW and TFHE perform differently: FHEW follows the approach from Alpein-Sherif-Peikert <a href="#AP14">[AP14]</a> and TFHE the one from Gama-Izabachene-Nguyen-Xie <a href="#GINX16">[GINX16]</a>.</p><p>Given as inputs:</p><ul><li>the mask $a \in \mathbb{Z}_q^n$ of an LWE ciphertext $(a, b) \in \mathrm{LWE}_s^q(m)$,</li><li>the initialized accumulator $(A, B) \in \mathrm{RLWE}_z^Q(\sum_{I=0}^{q/2} f(b-i) \cdot X^{i \cdot (2N/q)})$ and</li><li>the bootstrapping key $\mathrm{BSK}$ consisting of a collection of RGSW ciphertexts encrypting the components of the key $s \in \mathbb{Z}_q^n$ under key $z \in \mathcal{R}_Q$,</li></ul><p>the blind rotation procedure returns an updated accumulator:</p><p>$$(A', B') \in \mathrm{RLWE}_z^Q\left(\sum_{i=0}^{q/2} f(b-i) \cdot X^{(i-\textbf{a} \cdot \textbf{s}) \cdot (2N/q)}\right).$$</p><p>The difference in content between the input and output ciphertexts is that the latter is multiplied by the monomial $X^{(-a \cdot s) \cdot (2N/q)}$. That factor essentially performs a rotation of the coefficients of the polynomial, taking into account that operations are computed modulo $X^N+1$ (so $X^N \equiv -1$ and $X^{2N} \equiv 1$).</p><p>Fundamentally, FHEW and TFHE differ in how they multiply the content of the accumulator by $X^{(-a_j \cdot s_j) \cdot (2N/q)}$ for each step $j \in {0,\dots,n-1}$.</p><p>In both cases, the schemes rely on a multiplication operation between RLWE and RGSW ciphertexts. Let's assume for now that we know how to multiply them and let</p><p>$$\odot : \mathrm{RLWE} \times \mathrm{RGSW} \to \mathrm{RLWE}$$</p><p>denote that operation.</p><h4>FHEW's Accumulator Update</h4><p>The accumulator update of FHEW is parametrized by a refreshing base $B_r$ (in practice $B_r \approx 32$). We can denote the number of digits of $q$ in the base $B_r$ as $dr = \lceil \log_{B_r}q \rceil$.</p><p>Given as inputs:</p><ul><li>the mask $a \in \mathbb{Z}_q^n$ of an LWE ciphertext $(a, b) \in \mathrm{LWE}_s^q(m)$,</li><li>the initialized accumulator $(A, B) \in \mathrm{RLWE}_z^Q(\sum_{I=0}^{q/2} f(b-i) \cdot X^{i \cdot (2N/q)})$ and</li><li>the bootstrapping key $\mathrm{BSK}={\mathrm{bsk}_{i,j,v}}$ where</li></ul><p>$$ \mathrm{bsk}_{i,j,v} \in \mathrm{RGSW}_z^Q(X^{vB_r^js_i \cdot (2N/q)}),$$</p><p>$$i \in \{0,\dots,n-1\}, j \in \{0,\dots,dr-1\}, v \in \{0,\dots,B_r-1\}$$</p><p>the blind rotation procedure returns an updated accumulator:</p><p>$$(A', B') \in \mathrm{RLWE}_z^Q\left(\sum_{i=0}^{q/2} f(b-i) \cdot X^{(i-\textbf{a} \cdot \textbf{s}) \cdot (2N/q)}\right).$$</p><p>This procedure has a similar idea to the key switching previously explained. For each $i \in {0,\dots,n-1}$ we will decompose $-a_i \mathrm{mod} q$ under the base $B_r$, i.e.,</p><p>$$-a_i \equiv \sum_{j=0}^{dr-1}a_{i,j}B_r^j \mod q.$$</p><p>Then at each step $(i,j) \in {0,\dots,n} \times {0,\dots,dr-1}$ we will update the current value $\mathrm{ACC}$ of the accumulator as $\mathrm{ACC} := \mathrm{ACC} \odot \mathrm{bsk}<em>{i,j,a</em>{i,j}}$.</p><p>As for the pseudocode version:</p><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Accumulator Update <span class="token operator">-</span> FHEW</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE<span class="token punctuation">,</span> BSK<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>dr<span class="token punctuation">]</span><span class="token punctuation">[</span>Br<span class="token punctuation">]</span> of RGSW ciphertexts</span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>A'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> n<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">    c <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> q<span class="token punctuation">)</span></span>
<span class="highlight-line">    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> dr<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">        digit <span class="token operator">:=</span> c <span class="token operator">%</span> Br</span>
<span class="highlight-line">        key <span class="token operator">:=</span> BSK<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>digit<span class="token punctuation">]</span></span>
<span class="highlight-line">        <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span>  <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">⊙</span> key</span>
<span class="highlight-line">        c <span class="token operator">:=</span> c<span class="token operator">/</span>Br</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">return</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span></span></code></pre><p>Note that whenever $a_{i,j}=0$ for some $i \in {0,\dots,n-1},j \in {0,\dots dr-1}$, the respective $\mathrm{bsk}_{i,j,a_{i,j}}$ will just be an encryption of $1$. In that case, the multiplication $(A',B') \odot \mathrm{bsk}_{i,j,a_{i,j}}$ is redundant. Therefore, we can omit from $\mathrm{BSK}$ all the ciphertexts of the form $\mathrm{bsk}_{i,j,0}$ and only update the accumulator for those $(i,j)$ for which $a_{i,j} \neq 0$.</p><h4>TFHE's Accumulator Update</h4><p>The accumulator update procedure that we are going to describe is slightly different from TFHE's original version. The original construction strongly relies on the use of binary secret keys, but their security is currently not well understood. While the construction can be adapted to keys with larger components, the performance decays as the size increases. In such situations, the Homomorphic Encryption Standard <a href="#ACC+18">[ACC+18]</a> mentions the option of using ternary secret keys, i.e., with components uniformly distributed in ${-1, 0, 1}$. Fortunately, the performance of TFHE with ternary keys is close to the binary case by following the approach introduced in <a href="#JP22">[JP22]</a>. That is the version that OpenFHE implements and the one that we are going to cover.</p><p>Given as inputs:</p><ul><li>the mask $a \in \mathbb{Z}_q^n$ of an LWE ciphertext $(a, b) \in \mathrm{LWE}_s^q(m)$,</li><li>the initialized accumulator $(A, B) \in \mathrm{RLWE}_z^Q(\sum_{I=0}^{q/2} f(b-i) \cdot X^{i \cdot (2N/q)})$ and</li><li>the bootstrapping key $\mathrm{BSK}'={\mathrm{bsk}'_{i,j}}$ where</li></ul><p>$$ \mathrm{bsk}'_{i,j} \in \mathrm{RGSW}_z^Q(x_{i,j}),$$</p><p>$$s_i=x_{i,1} - x_{i,-1}, x_{i,j} \in \{0,1\}, x_{i,-1} \cdot x_{i,1} = 0,$$</p><p>$$i \in \{0,\dots,n-1\}, j \in \{-1, 1\}$$</p><p>the blind rotation procedure returns an updated accumulator:</p><p>$$(A', B') \in \mathrm{RLWE}_z^Q\left(\sum_{i=0}^{q/2} f(b-i) \cdot X^{(i-\textbf{a} \cdot \textbf{s}) \cdot (2N/q)}\right).$$</p><p>The bootstrapping key $\mathrm{BSK}'$ is quite different from the bootstrapping key $\mathrm{BSK}$ from FHEW. In this case, we are leveraging the fact that $s \in {-1,0,1}^n$ to decompose each of its components as $s_i = x_{i,1} - x_{i,-1}$ where:</p><ul><li>If $s_i = -1$, then $x_{i,-1} = 1$ and $x_{i,1}=0$.</li><li>If $s_i = 0$, then $x_{i,-1} = 0$ and $x_{i,1}=0$.</li><li>If $s_i = 1$, then $x_{i,-1} = 0$ and $x_{i,1}=1$.</li></ul><p>We will update the accumulator sequentially for each component $s_i$ of the mask. In each step $i \in {0,\dots,n-1}$, the value $\mathrm{ACC}$ of the accumulator will be updated as:</p><p>$$\mathrm{ACC} := \mathrm{ACC} + (X^{-a_i \cdot (2N/q)}-1) \cdot (\mathrm{ACC} \odot \mathrm{bsk}'_{i,1}) + (X^{a_i \cdot (2N/q)}-1) \cdot (\mathrm{ACC} \odot \mathrm{bsk}'_{i,-1}).$$</p><p>To see this in the pseudocode version:</p><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Accumulator Update <span class="token operator">-</span> TFHE</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE<span class="token punctuation">,</span> BSK'<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> of RGSW ciphertexts</span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>A'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> n<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">    exp1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> q<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>N<span class="token operator">/</span>q<span class="token punctuation">)</span></span>
<span class="highlight-line">    exp2 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">*</span>N</span>
<span class="highlight-line"></span>
<span class="highlight-line">    prod1 <span class="token operator">:=</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">⊙</span> BSK'<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span>
<span class="highlight-line">    prod2 <span class="token operator">:=</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">⊙</span> BSK'<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>X<span class="token operator">^</span>exp1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>prod1 <span class="token operator">+</span> <span class="token punctuation">(</span>X<span class="token operator">^</span>exp2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>prod2</span>
<span class="highlight-line">ENDFOR</span>
<span class="highlight-line"></span>
<span class="highlight-line">RETURN <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span></span></code></pre><h4>RLWE-RGSW multiplication</h4><p>As we can see from both versions of the blind rotation procedure, they strongly rely on a multiplication operation</p><p>$$\odot : \mathrm{RLWE} \times \mathrm{RGSW} \to \mathrm{RLWE}$$</p><p>between ciphertexts. We will now see what this operation looks like in detail.</p><p>Recall that</p><p>$$\mathrm{RLWE}_z^Q(m) \subseteq \mathcal{R}_Q^2,$$</p><p>and from them, we can construct</p><p>$$\mathrm{RLWE}_z^{'Q}(m) = (\mathrm{RLWE}_z^Q(m), \mathrm{RLWE}_z^Q(B_Gm), \dots, \mathrm{RLWE}_z^Q(B_G^{dg-1}m)) \subseteq (\mathcal{R}_Q^2)^{dg}$$</p><p>and</p><p>$$\mathrm{RGSW}_z^Q(m)=(\mathrm{RLWE}_z^{'Q}(-s \cdot m), \mathrm{RLWE}_z^{'Q}(m)) \subseteq ((\mathcal{R}_Q^2)^{dg})^2$$</p><p>where $B_G$ is the gadget base and $dg = \lceil \log_{B_G}(Q)\rceil$.</p><p>The first step of the multiplication is to perform a signed decomposition of all the coefficients of the two polynomials of the $\mathrm{RLWE}$ ciphertext.</p><p>For an integer $x \in \mathbb{Z}_Q$, its signed decomposition is of the form $(x_0,\dots,x_{dg-1})$, where</p><p>$$x = \sum_{i=0}^{dg-1} x_iB_G^i(\mathrm{mod} Q), x_i \in [0,B_G/2) \cup [Q-B_G/2, Q).$$</p><p>As a reference, in a standard digit decomposition, we would have $x_i \in [0, B_G].$</p><p>When applying a signed decomposition to a ciphertext $(A, B) \in \mathcal{R}_Q^2$, we obtain $2d_g$ polynomials $(A_0, B_0, \dots, A_{dg-1}, B_{dg-1}) \in \mathcal{R}_Q^{2dg}$ such that</p><p>$$A = \sum_{i=0}^{dg-1} A_iB_G^i(\mathrm{mod}Q),B = \sum_{i=0}^{dg-1} B_iB_G^i(\mathrm{mod}Q),$$</p><p>and all the coefficients of $A_i$ and $B_i$ are in $[0,B_G/2) \cup [Q-B_G/2, Q)$ for all $i \in {0,\dots,dg-1}$.</p><p>Parallelly, given an RGSW ciphertext</p><p>$$(c, c') \in \mathrm{RLWE}_z^{'Q}(-s\cdot m) \times \mathrm{RLWE}_z^{'Q}(m) \subseteq \mathrm{RGSW}_z^Q(m) \subseteq ((\mathcal{R}_Q^2)^{dg})^2,$$</p><p>we can express it as</p><p>$$(c_0, c'_0, \dots, c_{dg-1}, c'_{dg-1}) \in (\mathcal{R}_Q^2)^{2dg},$$</p><p>where each $c_i$ and $c_i'$ is an RLWE ciphertext containg two polynomials for $i \in {0,\dots,dg-1}$.</p><p>Finally, building upon the multiplication between a polynomial and an RLWE ciphertext,</p><p>$$(\cdot): \mathcal{R}_Q \times \mathrm{RLWE} \to \mathrm{RLWE}$$</p><p>$$p \cdot (A, B) := (p \cdot A, p \cdot B),$$</p><p>we can construct the multiplication between RLWE and RGSW ciphertexts as</p><p>$$(\odot) : \mathrm{RLWE} \times \mathrm{RGSW} \to \mathrm{RLWE}$$</p><p>$$(A, B) \odot (c, c'):= A_0 \cdot c_0+B_0 \cdot c'_0 + \cdots + A_{dg-1} \cdot c_{dg-1} + B_{dg-1} \cdot c'_{dg-1}$$</p><p>where $(A_0, B_0, \dots, A_{dg-1}, B_{dg-1}) \in \mathcal{R}_Q^{2dg}$ is the signed decomposition of $(A, B)$ and $(c_0, c'_0, \dots, c_{dg-1}, c'_{dg-1}) \in (\mathcal{R}_Q^2)^{2dg}$ is the expanded expression of $(c, c')$. Note that we are essentially performing a dot product between those two vectors.</p><p>Overall, we now know how to reduce that essential multiplication of ciphertexts to multiplications of polynomials in $\mathcal{R}_Q = \mathbb{Z}_Q[X]/(X^N+1)$. While we could just multiply polynomials via the <em>schoolbook</em> method and then reduce modulo $(X^N+1)$, the problem of multiplying polynomials in a ring has been deeply studied and there are far more efficient ways to do so. In particular, one can resort to the Number Theoretic Transform (NTT).</p><p>The NTT is a linear transformation that takes a polynomial in coefficient form and converts it to evaluation form. In particular, given a polynomial in $\mathcal{R}_Q$, which has N coefficients, the NTT converts it to an array of $N$ evaluation points in $\mathbb{Z}_Q$. The advantage of such transformation is that polynomials in evaluation form can be multiplied component-wise, requiring a total of $N$ multiplications in $\mathbb{Z}_Q$.</p><p>The inverse of the NTT is another linear transformation that we will denote by INTT and which is really close algorithmically to the NTT. By combining both transformations and the component-wise product ($\circ$), we can efficiently obtain the product of two polynomials $p_1, p_2 \in \mathcal{R}_Q$ as</p><p>$$p_1 \cdot p_2 = \mathrm{INTT}(\mathrm{NTT}(p_1) \circ \mathrm{NTT}(p_2)).$$</p><p>This is the method that we will apply to multiply polynomials in the context of the RLWE-RGSW multiplication.</p><p>We have to note that the special form of the ring that we are working with, i.e., $\mathbb{Z}_Q[X]/(X^N+1)$ where $N$ is a power of 2 and $Q \equiv 1(\mathrm{mod}~ 2N)$, requires a special type of NTT. We refer the interested reader to <a href="#LZ22">[LZ22]</a>.</p><h4>Integrating the NTT in the accumulator update</h4><p>We now describe the complete versions of the accumulator update integrating the NTT in the algorithms.</p><p>Since we want to multiply polynomials in evaluation form, we need to apply the NTT to the $2dg$ polynomials that come out of the signed decomposition, and we assume that the RGSW ciphertexts are directly provided with all its polynomials in evaluation form.</p><p>For the following iteration we need the polynomials to be again in coefficient form, so we will have to apply the INTT to the two polynomials of the accumulator right after the multiplication.</p><p>With that in mind, the final versions of the accumulator update can be described as follows:</p><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Accumulator Update <span class="token operator">-</span> FHEW</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE<span class="token punctuation">,</span> BSK<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>dr<span class="token punctuation">]</span><span class="token punctuation">[</span>Br<span class="token punctuation">]</span> of RGSW ciphertexts <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>dg<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>A'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> n<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">    c <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> q<span class="token punctuation">)</span></span>
<span class="highlight-line">    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> dr<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">        digit <span class="token operator">:=</span> c <span class="token operator">%</span> Br</span>
<span class="highlight-line">        key <span class="token operator">:=</span> BSK<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>digit<span class="token punctuation">]</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        dec <span class="token operator">:=</span> <span class="token function">SignedDecompose</span><span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token comment">// dec[2*dg][N]</span></span>
<span class="highlight-line">        dec <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token function">NTT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> dec<span class="token punctuation">]</span></span>
<span class="highlight-line">        A' <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span>dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> ⚬ key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>dg<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line">        B' <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span>dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> ⚬ key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>dg<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line">        <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token function">INTT</span><span class="token punctuation">(</span>A'<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">INTT</span><span class="token punctuation">(</span>B'<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        c <span class="token operator">:=</span> c<span class="token operator">/</span>Br</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">return</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span></span></code></pre><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Accumulator Update <span class="token operator">-</span> TFHE</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE<span class="token punctuation">,</span> BSK'<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> of RGSW ciphertexts <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>dg<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>A'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> RLWE</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token keyword">to</span> n<span class="token operator">-</span><span class="token number">1</span></span>
<span class="highlight-line">    exp1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> q<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>N<span class="token operator">/</span>q<span class="token punctuation">)</span></span>
<span class="highlight-line">    exp2 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">-</span>exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">*</span>N</span>
<span class="highlight-line"></span>
<span class="highlight-line">    binom1 <span class="token operator">:=</span> <span class="token function">NTT</span><span class="token punctuation">(</span>X<span class="token operator">^</span>exp1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="highlight-line">    binom2 <span class="token operator">:=</span> <span class="token function">NTT</span><span class="token punctuation">(</span>X<span class="token operator">^</span>exp2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    key1 <span class="token operator">:=</span> BSK'<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span>
<span class="highlight-line">    key2 <span class="token operator">:=</span> BSK'<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    dec <span class="token operator">:=</span> <span class="token function">SignedDecompose</span><span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token comment">// dec[2*dg][N]</span></span>
<span class="highlight-line">    dec <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token function">NTT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> dec<span class="token punctuation">]</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    prod1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span>dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> ⚬ key1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>dg<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line">    prod1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span>dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> ⚬ key1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>dg<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    prod2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span>dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> ⚬ key2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>dg<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line">    prod2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:=</span> <span class="token function">sum</span><span class="token punctuation">(</span>dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> ⚬ key2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">*</span>dg<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token punctuation">(</span>A'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">,</span> B'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>binom1 ⚬ prod1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> binom1 ⚬ prod1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line">    <span class="token punctuation">(</span>A'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">,</span> B'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">,</span> B'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>binom2 ⚬ prod2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> binom2 ⚬ prod2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line">    <span class="token punctuation">(</span>A'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">,</span> B'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token function">INTT</span><span class="token punctuation">(</span>A'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">INTT</span><span class="token punctuation">(</span>B'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="highlight-line">    </span>
<span class="highlight-line">    <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>A'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">,</span> B'<span class="token punctuation">{</span><span class="token punctuation">}</span>'<span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">return</span> <span class="token punctuation">(</span>A'<span class="token punctuation">,</span> B'<span class="token punctuation">)</span></span></code></pre><p>Note that in TFHE only a signed decomposition and a subsequent NTT to the array are needed for the two RLWE-RGSW multiplications that take place.</p><p>Another interesting remark is that in practice, instead of a signed decomposition, an approximate signed decomposition that ignores the first digit of the decomposition is performed. This approximate version allows one to save 2 NTTs per iteration (one per polynomial that is decomposed) at the cost of some tolerable additional error.</p><h3>Extraction</h3><p>Given the accumulator</p><p>$$(A, B) \in \mathrm{RLWE}_z^Q\left(\sum_{i=0}^{q/2} f(b-i) \cdot X^{(i-a\cdot s) \cdot (2N/q)}\right)$$</p><p>where $(a, b) \in \mathrm{LWE}_s^q(\tilde{m})$, we will extract an LWE ciphertext $(a',b') \in \mathrm{LWE}_{z'}^Q(\mathrm{f}(\tilde{m}))$.</p><p>The $N$ components of the mask $a'$ will be the $N$ coefficients of the mask $A$. Additionally, the second component $b'$ of the LWE ciphertext will just be the constant term of the polynomial $B$.</p><p>Note that by applying this method we will obtain an LWE ciphertext encrypted under the key $z'=(z_0,-z_{N-1},-z_{N-2},\dots,-z_1) \in \mathbb{Z}_Q^N$, where $z_i$ are the coefficients of the RLWE key $z \in \mathcal{R}_Q$ for $i \in {0,\dots, N-1}$. If we want to obtain an LWE ciphertext encrypted under the original key $z$ (or more precisely, under its coefficients), we can apply a signed permutation to the mask. However, we can also take care of this in the key switching procedure by switching directly from the key $z'$ to the key $s$.</p><p>The pseudocode of this method follows:</p><pre class="language-pseudocode"><code class="language-pseudocode"><span class="highlight-line">Extraction from the Accumulator</span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">input</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"><span class="token keyword">output</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>a'<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> b'<span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token punctuation">(</span>a'<span class="token punctuation">,</span> b'<span class="token punctuation">)</span> <span class="token operator">:=</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="highlight-line"></span>
<span class="highlight-line"><span class="token keyword">return</span> <span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> </span></code></pre><h2>Example: bootstrapped NAND gate</h2><p>The presented functional bootstrapping in FHEW and TFHE allows one to reduce the noise of a ciphertext while evaluating a negacyclic function $\mathrm{f}$. We will see now how to leverage such a procedure to construct a bootstrapped NAND gate.</p><p>In particular, given $(a_1, b_1) \in \mathrm{LWE}_s^q(\tilde{m}_1)$ and $(a_2, b_2) \in \mathrm{LWE}_s^q(\tilde{m}_2)$ we aim to obtain $(a_3, b_3) \in \mathrm{LWE}_s^q(\tilde{m}_3)$, such that $m_3 = m_1 \barwedge m_2$, where $m_1, m_2, m_3 \in {0,1}$.</p><p>Recall that $\tilde{m_i} = \lfloor qm_i/t\rceil$ is the encoding of $m_i$ for $i \in {1,2,3}$. Following the procedure of <a href="#DM15">[DM15]</a>, we will work with a plaintext modulus of $t=4$.</p><p>The idea is to compute the sum of the given ciphertexts:</p><p>$$(a_s, b_s) := (a_1, b_1) + (a_2, b_2) \in \mathrm{LWE}_s^q(\tilde{m_s})$$</p><p>where $m_s = m_1 + m_2 \in {0,1,2}$ and to take the resulting ciphertext $(a_s, b_s)$ as the input for the functional boostrapping.</p><p>Since $m_3$ represents the result of the NAND gate, whenever $m_s=0$ or $m_s=1$, we expect to obtain $m_3=1$, whereas when $m_s = 2$, it should be that $m_3=0$.</p><p>The encoding of the values $0$ and $1$ are $\tilde{0} = 0$ and $\tilde{1} = q/4$, which lie in the interval $(-q/8, 3q/8)$. Regarding the value $2$, we have that $\tilde{2} = q/2$, which lies in the other half $(3q/8, 7q/8)$.</p><p>Therefore we are looking for a function that maps the interval $(-q/8, 3q/8)$ to $q/4$ (which would be the encoding of the bit 1) and the interval $(3q/8, 7q/8)$ to 0 (which would be the encoding of the bit 0). However, such a function would not be negacyclic, i.e., it would not satisfy the requirement $\mathrm{f}(v + q/2)=-f(v)$.</p><p>To fix that issue, we can shift the function by $q/8$ and so work with one mapping $(-q/8, 3q/8)$ to $q/8$ and $(3q/8, 7q/8)$ to $-q/8$.</p><p>Finally, we need to take into account that we are looking for a function $f: \mathbb{Z}_q \to \mathbb{Z}_Q$, so we need to rescale the images to $\mathbb{Z}_Q$.</p><p>For that reason, we will work with the function</p><p>$$f: \mathbb{Z}_q \to \mathbb{Z}_Q$$</p><p>defined as</p><p>$$x \in [-q/8, 3q/8) \implies f(x)=Q/8$$</p><p>and</p><p>$$x \in [3q/8, 7q/8) \implies f(x)=-Q/8,$$</p><p>where the images of the endpoints have been set to ensure the negacyclic requirement.</p><p>Now if we introduce the ciphertext $(a_s, b_s) \in \mathrm{LWE}_s^q(\tilde{m_s})$ and the function $\mathrm{f}$ into the accumulator, we obtain after the extraction a ciphertext</p><p>$$(a_f, b_f) \in \mathrm{LWE}_{z'}^Q(f(\tilde{m}))$$</p><p>that encrypts $Q/8$ if the result of the NAND is 1 and $-Q/8$ if the result is 0.</p><p>To revert the shift in the function $\mathrm{f}$, we can add a noiseless encryption of $Q/8$ to obtain a ciphertext</p><p>$$(a_{f}, b_{f}+Q/8) \in \mathrm{LWE}_{z'}^Q(f(\tilde{m}) + Q/8).$$</p><p>Finally, by applying a modulus switch to the key switching modulus $Q_{ks}$, followed by a key switch to the original key $s$, and a final modulus switch to the original modulus $q$, we end up with</p><p>$$(a_3, b_3) \in \mathrm{LWE}_s^q(\tilde{m}_3)s.t.m_3 = m_1 \barwedge m_2$$</p><p>as we wanted.</p><h2>Conclusion</h2><p>FHEW and TFHE stand out for their fast functional bootstrapping procedure that allows one to reduce the noise of ciphertexts while evaluating a function. They can both be described in a unified framework following the approach of <a href="#MP21">[MP21]</a>. In such a framework, they both follow the structure of a first accumulator phase that performs the actual function evaluation and refreshing of the noise, followed by a modulus and key switching phase that transforms the ciphertext into one under the original parameters. The only difference between both schemes under this framework is how they perform the accumulator update or blind rotation. Overall, the functional bootstrapping presented can be leveraged to construct boolean gates such as the bootstrapped NAND gate from the last section.</p><p>The description contained in this blog post is a result of analyzing the theoretical description of the schemes, especially the ones found in <a href="#DM15">[DM15]</a> and <a href="#MP21">[MP21]</a>, and reverse-engineering OpenFHE's implementation <a href="#OpenFHE">[OpenFHE]</a>. We hope this post helps to bridge the gap between theory and practice that, from our point of view, existed for these schemes.</p><h2>References</h2><ul><li><a id="AP14">[AP14] <a href="https://eprint.iacr.org/2014/094.pdf" target="_blank" rel="noopener">J. Alperin-Sheriff and C. Peikert. Faster bootstrapping with polynomial error. In CRYPTO 2014, volume 8616 of Lecture Notes in Computer Science, pages 297–314, 2014</a></a></li><li><a id="CGGI20">[CGGI20] <a href="https://eprint.iacr.org/2018/421.pdf" target="_blank" rel="noopener">I. Chillotti, N. Gama, M. Georgieva, and M. Izabachène. TFHE: Fast fully homomorphic encryption over the torus. Journal of Cryptology, 33:34–91, 2020.</a></a></li><li><a id="DM15">[DM15] <a href="https://eprint.iacr.org/2014/816.pdf" target="_blank" rel="noopener">L. Ducas and D. Micciancio. FHEW: bootstrapping homomorphic encryption in less than a second. In EUROCRYPT (1), volume 9056 of Lecture Notes in Computer Science, pages 617–640. Springer, 2015.</a></a></li><li><a id="Gen09">[Gen09] <a href="https://dl.acm.org/doi/pdf/10.1145/1536414.1536440" target="_blank" rel="noopener">C. Gentry. Fully homomorphic encryption using ideal lattices. In STOC, pages 169–178. ACM, 2009.</a></a></li><li><a id="GINX16">[GINX16] <a href="https://eprint.iacr.org/2014/283.pdf" target="_blank" rel="noopener">N. Gama, M. Izabachène, P. Q. Nguyen, and X. Xie. Structural lattice reduction: Generalized worst-case to average-case reductions and homomorphic cryptosystems. In EUROCRYPT 2016, volume 9666 of Lecture Notes in Computer Science, pages 528–558, 2016.</a></a></li><li><a id="GSW13">[GSW13] <a href="https://eprint.iacr.org/2013/340.pdf" target="_blank" rel="noopener">C. Gentry, A. Sahai, and B. Waters. Homomorphic encryption from learning with errors: Conceptually-simpler, asymptotically-faster, attribute-based. In CRYPTO (1), volume 8042 of Lecture Notes in Computer Science, pages 75–92. Springer, 2013.</a></a></li><li><a id="ACC+18">[ACC+18] <a href="https://eprint.iacr.org/2019/939.pdf" target="_blank" rel="noopener">M. Albrecht, M. Chase, H. Chen, and et al. Homomorphic encryption security standard. Technical report, HomomorphicEncryption.org, Toronto, Canada, November 2018.</a></a></li><li><a id="J22">[J22] <a href="https://marcjoye.github.io/papers/Joy22dtorus.pdf" target="_blank" rel="noopener">Joye, M.: SoK: Fully homomorphic encryption over the [discretized] torus. IACR Transactions on Cryptographic Hardware and Embedded Systems, 661–692 (2022)</a></a></li><li><a id="JP22">[JP22] <a href="https://marcjoye.github.io/papers/JP22ternary.pdf" target="_blank" rel="noopener">Joye, M., Paillier, P.: Blind rotation in fully homomorphic encryption with extended keys. In: Dolev, S., Katz, J., Meisels, A. (eds.) Cyber Security, Cryptology, and Machine Learning. CSCML 2022. LNCS, vol. 13301, pp. 1–18. Springer, Cham (2022).</a></a></li><li><a id="LMK+23">[LMK+23] <a href="https://eprint.iacr.org/2022/198.pdf" target="_blank" rel="noopener">Yongwoo Lee, Daniele Micciancio, Andrey Kim, Rakyong Choi, Maxim Deryabin, Jieun Eom, and Donghoon Yoo. Efficient fhew bootstrapping with small evaluation keys, and applications to threshold homomorphic encryption. In Carmit Hazay and Martijn Stam, editors, Advances in Cryptology – EUROCRYPT 2023, pages 227–256, Cham, 2023. Springer Nature Switzerland.</a></a></li><li><a id="LZ22">[LZ22] <a href="https://arxiv.org/abs/2211.13546.pdf" target="_blank" rel="noopener">Zhichuang Liang and Yunlei Zhao. Number theoretic transform and its applications in lattice-based cryptosystems: A survey. arXiv preprint arXiv:2211.13546, 2022.</a></a></li><li><a id="MP21">[MP21] <a href="https://eprint.iacr.org/2020/086.pdf" target="_blank" rel="noopener">Daniele Micciancio and Yuriy Polyakov. Bootstrapping in FHEW-like cryptosystems. In Proceedings of the 9th Workshop on Encrypted Computing &amp; Applied Homomorphic Cryptography, WAHC ’21, page 17–28, New York, NY, USA, 2021. Association for Computing Machinery.</a></a></li><li><a id="OpenFHE">[OpenFHE] <a href="https://github.com/openfheorg/openfhe-development" target="_blank" rel="noopener">OpenFHE - Open-Source Fully Homomorphic Encryption Library. https://github.com/openfheorg/openfhe-development (2023)</a></a></li><li><a id="TFHE-rs">[TFHE-rs] <a href="https://docs.zama.ai/tfhe-rs" target="_blank" rel="noopener">TFHE-rs: Pure Rust implementation of the TFHE scheme for boolean and integers FHE arithmetics. https://docs.zama.ai/tfhe-rs (2023)</a></a></li><li><a id="XZD+23">[XZD+23] <a href="https://eprint.iacr.org/2023/1564.pdf" target="_blank" rel="noopener">Binwu Xiang, Jiang Zhang, Yi Deng, Yiran Dai, and Dengguo Feng. Fast blind rotation for bootstrapping FHEs. In Helena Handschuh and Anna Lysyanskaya, editors, Advances in Cryptology – CRYPTO 2023, pages 3–36, Cham, 2023. Springer Nature Switzerland.</a></a></li><li><a id="ZAMA">[ZAMA] <a href="https://www.zama.ai/post/tfhe-deep-dive-part-1" target="_blank" rel="noopener">TFHE Deep Dive</a></a></li></ul></div><div class="bg-gray-400 mt-16 mb-4" style="height: 1px;"></div><div class="flex mb-4"><div><img class="h-16 object-center w-16 rounded-full m-auto object-cover" src="/images/people/students/Christian_Knabenhans.png" alt="Christian Knabenhans"></div><div class="flex flex-col ml-4 mt-1 text-gray-600"><div><a href="https://cknabs.github.io/" target="_blank" rel="noopener"><span>Christian Knabenhans</span></a></div><div class="flex flex-row mt">Published on&nbsp; <time datetime="Fri Oct 27 2023 00:00:00 GMT+0000 (Coordinated Universal Time)">27.10.2023</time><p class="px-2">—</p><div class="flex-col"><a href="https://github.com/zkFHE/circomlib-fhe" rel="noopener" aria-label="Github circomlib-FHE" target="_blank" style="display: inline-flex;"><svg style="margin-top: -2px;" class="fill-current" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22" height="22" viewBox="0 0 22 22"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg> <span class="ml-2">circomlib-FHE</span></a></div></div></div></div><div class="bg-gray-400" style="height: 1px;"></div><div class="mt-8 md:px-16"><div class="flex justify-between mt-16"><p class="text-gray-700 text-md"><span>Previous:</span> <a href="/blog/fhe_arithmetization/">Arithmetizing FHE in Circom</a></p></div></div></div></article></main><div class="footer-wrapper"><footer id="footer" class="footer"><div class="inner m-auto md:flex justify-between items-center py-10"><a href="https://ethz.ch" class="block text-gray-500 hover:text-pink-500" target="_blank" rel="noopener noreferrer"><span class="sr-only">ETH</span> <img src="https://pps-lab.com/images/logo/eth_logo_cropped.png" alt="ETH logo" class="h-10"></a></div></footer></div></div><nav id="mobile-nav" class="mobile-nav fixed left-0 top-0 h-screen w-full overflow-y-auto pt-12 bg-gray-200 z-50 md:hidden"><ul><li class="item relative opacity-0"><a href="/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Home</a></li><li class="item relative opacity-0"><a href="/people/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">People</a></li><li class="item relative opacity-0"><a href="/research/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Research</a></li><li class="item relative opacity-0"><a href="/publications/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Publications</a></li><li class="item relative opacity-0"><a href="/teaching/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Teaching</a></li><li class="item relative opacity-0"><a href="/funding/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Funding</a></li><li class="item relative opacity-0"><a href="/blog/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Blog</a></li></ul></nav><button id="mobile-nav-toggle" class="mobile-nav-toggle block fixed h-16 w-full bottom-0 flex items-center justify-center font-bold border-none bg-gray-200 text-dark z-50 focus:outline-none md:hidden" aria-label="Mobile menu toggle" aria-expanded="false" aria-controls="mobile-nav"><span class="mobile-nav-label mr-2 font-medium">Menu</span> <span class="mobile-nav-icon" aria-hidden="true"><span class="mobile-nav-icon-line bg-black w-6 block transition-all duration-200 ease-out mb-1"></span> <span class="mobile-nav-icon-line bg-black w-6 block transition-all duration-200 ease-out mb-1"></span> <span class="mobile-nav-icon-line bg-black w-6 block transition-all duration-200 ease-out"></span></span></button><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true},
            jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
            TeX: {
            extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
            equationNumbers: {
            autoNumber: "AMS"
            }
          }
        });</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script></body></html>