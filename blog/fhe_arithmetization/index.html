<!doctype html><html lang="en" class="min-h-full antialiased"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Arithmetizing FHE in Circom | Privacy Preserving Systems Lab</title><meta name="description" content="Fully Homomorphic Encryption (FHE) allows one to perform computations on encrypted data, making it particularly useful for providing privacy to computations. The privacy guarantees of FHE schemes can however be threatened by parties with access to a partial decryption oracle, i.e., when they can distinguish whether the ciphertext sent to another party decrypted correctly or not. Moreover, in many settings, the parties would like to receive some guarantee of the correctness of the computation that has been performed."><meta name="robots" content="index,follow"><link rel="preload" href="fonts/gillsans/Gill_Sans_Medium.otf"><link rel="preload" href="fonts/sourceserifpro/source-serif-pro-400-normal.woff"><link rel="preload" href="fonts/sourceserifpro/source-serif-pro-400-italic.woff"><link rel="stylesheet" href="/css/main.min.css"><script src="/js/main.min.js" defer="defer"></script><meta itemprop="name" content="Arithmetizing FHE in Circom | Privacy Preserving Systems Lab"><meta itemprop="description" content="Fully Homomorphic Encryption (FHE) allows one to perform computations on encrypted data, making it particularly useful for providing privacy to computations. The privacy guarantees of FHE schemes can however be threatened by parties with access to a partial decryption oracle, i.e., when they can distinguish whether the ciphertext sent to another party decrypted correctly or not. Moreover, in many settings, the parties would like to receive some guarantee of the correctness of the computation that has been performed."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Arithmetizing FHE in Circom | Privacy Preserving Systems Lab"><meta name="twitter:description" content="Fully Homomorphic Encryption (FHE) allows one to perform computations on encrypted data, making it particularly useful for providing privacy to computations. The privacy guarantees of FHE schemes can however be threatened by parties with access to a partial decryption oracle, i.e., when they can distinguish whether the ciphertext sent to another party decrypted correctly or not. Moreover, in many settings, the parties would like to receive some guarantee of the correctness of the computation that has been performed."><meta name="twitter:site" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content="https://pps-lab.com"><meta name="og:title" content="Arithmetizing FHE in Circom | Privacy Preserving Systems Lab"><meta name="og:description" content="Fully Homomorphic Encryption (FHE) allows one to perform computations on encrypted data, making it particularly useful for providing privacy to computations. The privacy guarantees of FHE schemes can however be threatened by parties with access to a partial decryption oracle, i.e., when they can distinguish whether the ciphertext sent to another party decrypted correctly or not. Moreover, in many settings, the parties would like to receive some guarantee of the correctness of the computation that has been performed."><meta name="og:image" content="https://pps-lab.com"><meta name="og:url" content="https://pps-lab.com/blog/fhe_arithmetization/"><meta name="og:site_name" content="Privacy Preserving Systems Lab"><meta name="og:locale" content="en_GB"><meta name="og:type" content="website"><link rel="icon" type="image/png" href="/images/favicon/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"><link rel="manifest" href="/images/favicon/site.webmanifest"><link rel="canonical" href="https://pps-lab.com/blog/fhe_arithmetization/"><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-4ZPP8W4RNN"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-4ZPP8W4RNN');</script></head><body id="blog" class="leading-normal bg-white dark:bg-black"><a class="sr-only" href="#main">Skip to content</a><div id="wrapper" class="wrapper pb-16 md:pb-0 flex flex-col relative min-h-screen"><div class=""><header id="header" class="inner header flex flex-col md:flex-row md:justify-start items-center p-2 md:p-4"><a class="company-logo-link block hover:text-link-hover" href="/" title="Privacy Preserving Systems Lab home"><div></div></a><nav id="nav" class="nav hidden md:flex flex-grow"><ul class="menu list-reset text-base flex flex-row justify-between flex-grow"><div class="flex flex-col md:flex-row items-center"><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/" class="link text-black">Home</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/people/" class="link text-black">People</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/research/" class="link text-black">Research</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/publications/" class="link text-black">Publications</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/teaching/" class="link text-black">Teaching</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/funding/" class="link text-black">Funding</a></li><li class="level-1 mb-4 md:mr-8 md:mb-0"><a href="/blog/" class="link text-black">Blog</a></li></div><li class="level-1 mb-4 md:mb-0"><a href="https://github.com/pps-lab" rel="noopener" aria-label="Github" target="_blank" class="link text-black"><svg class="fill-current" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22" height="22" viewBox="0 0 22 22"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg></a></li></ul></nav></header></div><main id="main" class="main inner flex flex-1 flex-col py-10 lg:py-20 focus:outline-none text-lg" tabindex="-1"><article id="container-centre" class="column centre flex-1"><div class="blog-container"><header><h1 class="page-title font-title text-3xl">Arithmetizing FHE in Circom</h1></header><div class="flex mb-8"><div><img class="h-16 object-center w-16 rounded-full m-auto object-cover" src="/images/people/students/Christian_Knabenhans.png" alt="Christian Knabenhans"></div><div class="flex flex-col ml-4 mt-1 text-gray-600"><div><a href="https://cknabs.github.io/" target="_blank" rel="noopener"><span>Christian Knabenhans</span></a></div><div class="flex flex-row mt">Published on&nbsp; <time datetime="Fri Oct 27 2023 00:00:00 GMT+0000 (Coordinated Universal Time)">27.10.2023</time><p class="px-2">â€”</p><div class="flex-col"><a href="https://github.com/zkFHE/circomlib-fhe" rel="noopener" aria-label="Github circomlib-FHE" target="_blank" style="display: inline-flex;"><svg style="margin-top: -2px;" class="fill-current" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22" height="22" viewBox="0 0 22 22"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg> <span class="ml-2">circomlib-FHE</span></a></div></div></div></div><div class="content post leading-relaxed md-content-blog"><p><em>This blog post is part of a series about our project on integrity protection for fully homomorphic encryption using zero-knowledge proofs, and was written by <a href="https://amerigal.github.io/">Antonio Merino Gallardo</a> as part as a semester project in the PPS Lab.</em></p><p><em>Previous post in this series: <a href="/blog/fhew_tfhe/">A primer on the FHEW &amp; TFHE schemes</a></em></p><h1>Arithmetization of FHEW &amp; TFHE</h1><p>Fully Homomorphic Encryption (FHE) allows one to perform computations on encrypted data, making it particularly useful for providing privacy to computations. The privacy guarantees of FHE schemes can however be threatened by parties with access to a partial decryption oracle, i.e., when they can distinguish whether the ciphertext sent to another party decrypted correctly or not. Moreover, in many settings, the parties would like to receive some guarantee of the correctness of the computation that has been performed. Both issues can be addressed by combining FHE with Zero-Knowledge Proofs (ZKPs). This way, a proof of correctness can be attached to the result of the computation while hiding the private inputs. That combination, however, raises some challenges.</p><h2>What is the role of R1CS constraints and what do they look like?</h2><p>In order to be able to prove some computation, it needs to be in the right form. The general idea is to express computations as an arithmetic circuit, which defines a collection of R1CS constraints. These constraints in a Rank-1 constraint system (R1CS) can be then introduced into a ZKP system.</p><p>The variables of a circuit are called signals. The circuit takes some input signals, computes a series of intermediate signals, and finally outputs one or more output signals. R1CS constraints determine the relation between these signals, i.e., how one signal is obtained from the others, and those relations are defined by the addition and multiplication gates of the circuit.</p><p>Circuits are defined over some finite field $\mathbb{F}_p$ for some large prime $p$. In this sense, their addition and multiplications gates perform additions and multiplications modulo $p$. Moreover, all the signals of the circuits, and hence all the values that appear in the R1CS constraints, are in $\mathbb{F}_p$.</p><p>Given a circuit with signals $s_1, \dots, s_n$, the R1CS constraints are equations of the form</p><p>$$(a_1 \cdot s_1 + \dots + a_n \cdot s_n) \cdot (b_1 \cdot s_1 + \dots + b_n \cdot s_n) + (c_1 \cdot s_1 + \dots + c_n \cdot s_n) = 0,$$</p><p>where $a_i, b_i, c_i \in \mathbb{F}_p$ for all $i \in {0, \dots, n}$.</p><p>Note that those equations can be constant, linear, or quadratic equations. Those are the types of expressions that we will need to transform our computations into.</p><h2>Challenges of arithmetizing FHEW &amp; TFHE</h2><p>In order to prove FHE computations via ZKPs, as we have seen in the last section, we will need to express those computations as an arithmetic circuit over some finite field $\mathbb{F}_p$ so as to generate the R1CS constraints that can be later introduced into the ZKP system.</p><p>We will focus on FHEW and TFHE, two FHE schemes that stand out for their fast bootstrapping operation. In a previous blog post [], we provide a thorough description of all the operations that those schemes involve. Based on those operations, we can point out some of the challenges to overcome when arithmetizing those FHE schemes:</p><ul><li>Mismatch between the rings from FHE ($\mathbb{Z}_q$ and $\mathbb{Z}_Q[X]/(X^N+1)$) and the finite field $\mathbb{F}_p$ for R1CS.</li><li>Rounding in the modulus switching.</li><li>Multiple digit decompositions in different bases and signed decomposition.</li><li>Array accesses to indices that are not known statically, e.g. in the key switching, or in FHEW's accumulator update.</li><li>Heavy use of Number Theoretic Transforms (NTTs).</li><li>Big RLWE-RGSW multiplication with many modular reductions.</li></ul><p>In the next few sections, we will go into detail about how to approach the arithmetization of some particular operations. The example code will be written in Circom, a language tailored to arithmetic circuits and the definition of R1CS constraints. For a full arithmetization of FHEW and TFHE in Circom check out <a href="https://github.com/zkFHE/circomlib-fhe">our repository</a>.</p><h2>Warmup: Modular Reduction</h2><p>The mismatch between the rings that FHE schemes use, i.e., $\mathbb{Z}_q$ and $\mathbb{Z}_Q[X]/(X^N+1)$, and the finite field $\mathbb{F}_p$ of R1CS, requires us to perform reductions modulo $q$ or $Q$ so as to emulate the rings inside the finite field. As a reference, in practice we deal with $q=1024$, $Q\approx 2^{27}$ and $N=1024$, whereas the prime field modulus of circom is $p \approx 2^{254}.$</p><p>Therefore, the modular reduction is a core operation that needs arithmetizing. While it is not a complex operation, it is a good example to showcase how to arithmetize with Circom and how to optimize the number of constraints.</p><p>A first approach to arithmetize the modular reduction could look as follows:</p><pre class="language-circom"><code class="language-circom"><span class="highlight-line"><span class="token class-name">template</span> <span class="token function">Mod</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">input</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> quotient<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">output</span> out<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    quotient <span class="token operator">&lt;</span><span class="token operator">--</span> in <span class="token operator">\</span> q<span class="token punctuation">;</span></span>
<span class="highlight-line">    out <span class="token operator">&lt;</span><span class="token operator">--</span> in <span class="token operator">%</span> q<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    in <span class="token operator">===</span> quotient <span class="token operator">*</span> q <span class="token operator">+</span> out<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token function">LtConstant</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"><span class="token punctuation">}</span></span></code></pre><p>The template works with an input signal <code>in</code>, an intermediate signal <code>quotient</code>, and an output signal <code>out</code>. It also receives a parameter $q$, which is the modulus for the reduction. The idea of the template is to compute <code>in % q</code> and put it in the output signal <code>out</code>.</p><p>The assignment <code>out &lt;-- in % q</code> would suffice if we just wanted to compute the result. However, we also want to introduce the constraints relating the signal input <code>in</code> to the output signal <code>out</code>, and the operator <code>%</code> doesn't fit with the R1CS constraints we need to generate. Therefore, the assignment we have just shown is an unsafe one, it performs the computation without constraining the signals. On the contrary, whenever we assign an expression that can directly form an R1CS constraint we can use the operator <code>&lt;==</code>.</p><p>In order to constrain the signal <code>out</code>, we store the quotient of the division <code>in/q</code> in an intermediate signal <code>quotient &lt;-- in \ q</code>. Note that in Circom, the operator <code>\</code> refers to the integer division. With such a signal, we can introduce a constraint expressing the equation of the division</p><pre class="language-circom"><code class="language-circom"><span class="highlight-line">in <span class="token operator">===</span> quotient <span class="token operator">*</span> q <span class="token operator">+</span> out</span></code></pre><p>Additionally, we need to constrain the signal <code>out</code> to be less than the modulus <code>q</code>. To do this, we can use the gadget <code>LtConstant(q)(out)</code> which precisely introduces the constraint <code>out &lt; q</code> in an arithmetic way. In order to do so, that gadget introduces $\log_2(q)$ constraints.</p><p>If we were working over the integers, those two constraints would suffice, as a unique quotient and remainder satisfy the division equation with a remainder less than the divisor. However, we are working inside $\mathbb{F}_p$, where the integer division doesn't behave as naturally. For instance, for $in' = 11$, $q' = 7$ and $p' = 23$ we have that</p><p>$$in' = 1 \cdot q' + 4 \mod p'$$</p><p>and</p><p>$$in' = 4 \cdot q' + 6 \mod p'.$$</p><p>The problem comes from the potential overflow of <code>quotient * q</code>. If that product is larger than or equal to <code>p</code>, then it will be reduced modulo <code>p</code>. To avoid this, we need to introduce an upper bound on the quotient so as to enforce that the product doesn't overflow. The following code introduces such a constraint:</p><pre class="language-circom"><code class="language-circom"><span class="highlight-line"><span class="token class-name">template</span> <span class="token function">Mod</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">input</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> quotient<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">output</span> out<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    quotient <span class="token operator">&lt;</span><span class="token operator">--</span> in <span class="token operator">\</span> q<span class="token punctuation">;</span></span>
<span class="highlight-line">    out <span class="token operator">&lt;</span><span class="token operator">--</span> in <span class="token operator">%</span> q<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    in <span class="token operator">===</span> quotient <span class="token operator">*</span> q <span class="token operator">+</span> out<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token function">LtConstant</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token keyword">var</span> bound_quot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">253</span><span class="token punctuation">)</span><span class="token operator">\</span>q<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token function">LtConstant</span><span class="token punctuation">(</span>bound_quot<span class="token punctuation">)</span><span class="token punctuation">(</span>quotient<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"><span class="token punctuation">}</span></span></code></pre><p>This approach assumes that the input <code>in</code> is less than $2^{253}$, which could be ensured in the functions that use this gadget, and bounds the quotient imposing <code>quotient &lt; (2**253)\q</code>. This version works fine and we could even avoid introducing assumptions on the input by replacing $2^{253}$ with the actual value of Circom's prime $p$.</p><p>By compiling the circuit we can check the number of constraints that this gadget generates for a given modulus. Interestingly, the number of constraints is $254$, independently of the modulus used. Apart for the constraint for the division, the gadget <code>LtConstant(q)</code> introduces $\log_2(q)$ constraints and the gadget <code>LtConstant((2**253)\q)</code> introduces $\log_2(2^{253}/q) = 253 - \log_2(q)$ constraints.</p><p>Considering that we will make heavy use of the modular reduction, it is worth taking a closer look in case we can reduce the number of constraints. An example will hint at one issue to solve. In the context of an RLWE-RGSW multiplication, we need to perform a reduction modulo $Q$ of values which can be at most $2^{57}$. However, with the gadget we just introduced, the quotient will be bounded assuming that the input can be up to $2^{253}$. Following the previous analysis, that bound on the quotient takes 226 out of the total 254 constraints.</p><p>Essentially, we can significantly reduce the number of constraints by introducing a tighter bound on the quotient based on a known bound on the input. We can modify our gadget to receive the bound on the input as a parameter.</p><pre class="language-circom"><code class="language-circom"><span class="highlight-line"><span class="token class-name">template</span> <span class="token function">ModBound</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">input</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> quotient<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">output</span> out<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    quotient <span class="token operator">&lt;</span><span class="token operator">--</span> in <span class="token operator">\</span> q<span class="token punctuation">;</span></span>
<span class="highlight-line">    out <span class="token operator">&lt;</span><span class="token operator">--</span> in <span class="token operator">%</span> q<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    in <span class="token operator">===</span> quotient <span class="token operator">*</span> q <span class="token operator">+</span> out<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token function">LtConstant</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token keyword">var</span> bound_quot <span class="token operator">=</span> b<span class="token operator">\</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token function">LtConstant</span><span class="token punctuation">(</span>bound_quot<span class="token punctuation">)</span><span class="token punctuation">(</span>quotient<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"><span class="token punctuation">}</span></span></code></pre><p>With this new approach, the number of constraints generated is $log_2(b) + 1$ assuming that $b &gt;= q$. For the previous example, this results in 58 constraints, as opposed to the 254 from the other approach.</p><h2>Signed Decomposition</h2><p>The signed decomposition is an expensive operation required for the RLWE-RGSW multiplication, though it can be described independently from FHE.</p><p>As a first step, we can describe this operation over arbitrary integers. Given an integer $a \in \mathbb{Z}$ and a base $B \in \mathbb{N}$, the idea is to decompose $a$ in base $B$ as a vector $(a_0, \dots, a_{k-1}) \in \mathbb{Z}^k$ satisfying</p><p>$$a = \sum_{i=0}^{k-1}a_i B^i.$$</p><p>In a standard digit decomposition we want that $a_i \in [0, B)$ for all $i \in {0,...,k-1}$. In a signed decomposition, however, the components need to be $a_i \in [-B/2, B/2]$ for all $i \in {0,\dots,k-1}$.</p><p>We move now to the setting of integers modulo $Q$, which is the one we will be working with. Given $a \in \mathbb{Z}_Q$ and a base $B \in \mathbb{N}$, a signed decomposition of $a$ in base $B$ is a vector $(a_0,\dots,a_{dg-1}) \in \mathbb{Z}^{dg}$ satisfying</p><p>$$a = \sum_{i=0}^{dg-1}a_iB^i \mod Q$$</p><p>and such that $a_i \in [0,B/2] \cup [Q-B/2, Q)$ for all $i \in {0,\dots,dg-1}$. The value $dg$ denotes the number of digits of $Q$ in base $B$, i.e., $dg = \lceil \log_B(Q)\rceil$. Note that the interval $[Q-B/2, Q)$ corresponds to the interval of negative integers $[-B/2, 0)$ shifted modulo $Q$.</p><p>With such restrictions, the maximum decomposable number is</p><p>$$\sum_{i=0}^{dg-1}(B/2)B^i = (B/2)\cdot \frac{B^{dg}-1}{B-1} \geq (B/2)\cdot \frac{Q-1}{B-1} \geq \frac{Q-1}{2}.$$</p><p>This means that we can effectively decompose with $dg$ digits any integer in the range $[0, Q/2)$. However, this will not always be the case for integers in the range $[Q/2, Q)$.</p><p>In order to deal with that issue, whenever the input integer $a \in \mathbb{Z}_Q$ is in the range $[Q/2, Q)$, we can sign-decompose $Q-a \in (0, Q/2]$ and then negate modulo $Q$ all the components of the decomposition. Note that for an odd $Q$ all integers in $\mathbb{Z}_Q$ are guaranteed to be decomposable with this approach and, in practice, we will work with $Q$ a prime of 27 bits.</p><p>We will assume for now that we have a <code>SignedDigitDecomposeInner</code> function that receives an integer $in \in [0, Q/2)$ and returns its signed decomposition. Let's see how to use it to solve the general case for $in \in [0, Q)$ following the described approach. The main problem is that we cannot branch our circuit depending on whether $a$ is in the lower or upper half of the interval since that can't be directly expressed as an R1CS constraint. We will need to rely on a compartor gadget <code>IsGtConstant</code> that returns $1$ whenever the input is greater than the given constant and $0$ otherwise. This gadget requires the input to be in binary form.</p><p>Here is a Circom solution to the general case:</p><pre class="language-circom"><code class="language-circom"><span class="token comment">/*
<span class="highlight-line">    Given in an integer mod Q, return its signed decomposition in base Bg.</span>
<span class="highlight-line">    Denoting dg = ceil(log_{Bg}(Q)), the output is a vector of dg components </span>
<span class="highlight-line">    where each component is in the range [0, Bg/2]U[Q-Bg/2, Q)</span>
<span class="highlight-line">    and in = sum_i(out[i]*Bg^i) mod Q.</span>
*/</span>
<span class="highlight-line"><span class="token class-name">template</span> <span class="token function">SignedDigitDecompose</span><span class="token punctuation">(</span>Bg<span class="token punctuation">,</span> Q<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> dg <span class="token operator">=</span> <span class="token function">logb</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> Bg<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> nbits <span class="token operator">=</span> <span class="token function">log2</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">input</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">output</span> out<span class="token punctuation">[</span>dg<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token comment">// compute the binary decomposition of in (needed for IsGtConstant)</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token punctuation">{</span>binary<span class="token punctuation">}</span> bits_in<span class="token punctuation">[</span>nbits<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> <span class="token function">Num2Bits</span><span class="token punctuation">(</span>nbits<span class="token punctuation">)</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token comment">// is_neg = (in > Q/2) ? 1 : 0</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token punctuation">{</span>binary<span class="token punctuation">}</span> is_neg <span class="token operator">&lt;=</span><span class="token operator">=</span> <span class="token function">IsGtConstant</span><span class="token punctuation">(</span>Q<span class="token operator">></span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">,</span> nbits<span class="token punctuation">)</span><span class="token punctuation">(</span>bits_in<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    </span>
<span class="highlight-line">    <span class="token comment">// new_in = (in > Q/2) ? (Q - in) : in</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> neg_in <span class="token operator">=</span> Q <span class="token operator">-</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> new_in <span class="token operator">=</span> is_neg<span class="token operator">*</span><span class="token punctuation">(</span>neg_in <span class="token operator">-</span> in<span class="token punctuation">)</span> <span class="token operator">+</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token comment">// compute decomposition for input new_in in range [0, Q/2]</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> dec<span class="token punctuation">[</span>dg<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">SignedDigitDecomposeInner</span><span class="token punctuation">(</span>Bg<span class="token punctuation">,</span> Q<span class="token punctuation">)</span><span class="token punctuation">(</span>new_in<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token keyword">signal</span> neg_out<span class="token punctuation">[</span>dg<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>dg<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="highlight-line">        <span class="token comment">// neg_out[i] = (-dec[i] mod Q)</span></span>
<span class="highlight-line">        neg_out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> <span class="token function">FastSubMod</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        <span class="token comment">// out[i] = (in > Q/2) ? neg_out[i] : dec[i]</span></span>
<span class="highlight-line">        out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> is_neg<span class="token operator">*</span><span class="token punctuation">(</span>neg_out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> dec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token punctuation">}</span></span>
<span class="highlight-line"><span class="token punctuation">}</span></span></code></pre><p>An alternative solution would be to call <code>SignedDigitDecomposeInner</code> for both $in$ and $Q-in$ and then select the desired result based on the comparison value. However, that would result in performing almost twice as many computations. As a general rule, it is preferable to make the selection as soon as possible to avoid unnecessary computations.</p><p>Overall, we have seen how to reduce our general problem to the problem of computing the signed decomposition of an integer $a \in [0, Q/2)$ in base $B$. To arithmetize this computation, it will be convenient to assume that the base $B$ is a power of $2$, and this will always be the case in our FHE context (in practice we work with $B=128$).</p><p>The strategy we will follow is:</p><ol><li>Decompose $a$ in base $2$.</li><li>Compute the standard digit decomposition of $a$ in base $B$ by grouping the bits corresponding to each digit in base $B$. Here we are leveraging the fact that $B$ is a power of $2$. After this, the $dg$ components will be in the range $[0, B)$.</li><li>Go through the standard digit decomposition from the least significant digit to the most significant digit. If the digit is greater than $B/2$ then subtract $B$ to this digit and sum $1$ to the following digit.</li></ol><p>Instead of computing the whole standard decomposition first (step 2) and then transforming it to the signed one (step 3), we will actually do it digit by digit. Starting from the least significant digit, we can compute its standard version by summing up the corresponding bits, then subtract the base if necessary and save the carry for the following digit. The following Circom code reflects this approach:</p><pre class="language-circom"><code class="language-circom"><span class="token comment">/*
<span class="highlight-line">    Given in an integer mod Q, return its signed decomposition in base Bg. </span>
<span class="highlight-line">    Denoting dg = ceil(log_{Bg}(Q)), the output is a vector of dg components </span>
<span class="highlight-line">    each component is in the range [0, Bg/2]U[Q-Bg/2, Q) and </span>
<span class="highlight-line">    in = sum_i(out[i]*Bg^i) mod Q.</span>
<span class="highlight-line">    in is assumed to allow for a signed decomposition of dg digits</span>
*/</span>
<span class="highlight-line"><span class="token class-name">template</span> <span class="token function">SignedDigitDecomposeInner</span><span class="token punctuation">(</span>Bg<span class="token punctuation">,</span> Q<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> dg <span class="token operator">=</span> <span class="token function">logb</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> Bg<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> nbitsBg <span class="token operator">=</span> <span class="token function">log2</span><span class="token punctuation">(</span>Bg<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">var</span> nbits <span class="token operator">=</span> dg <span class="token operator">*</span> nbitsBg<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">input</span> in<span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token keyword">output</span> out<span class="token punctuation">[</span>dg<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token comment">// compute binary decomposition of in</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token punctuation">{</span>binary<span class="token punctuation">}</span> bits_in<span class="token punctuation">[</span>nbits<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> <span class="token function">Num2Bits</span><span class="token punctuation">(</span>nbits<span class="token punctuation">)</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token keyword">var</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> digits<span class="token punctuation">[</span>dg<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token keyword">signal</span> <span class="token punctuation">{</span>binary<span class="token punctuation">}</span> bits_digit<span class="token punctuation">[</span>dg<span class="token punctuation">]</span><span class="token punctuation">[</span>nbitsBg<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">    <span class="token comment">// iterate through each digit of the decomposition</span></span>
<span class="highlight-line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>dg<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">        <span class="token comment">// initialize digit with the carry from the previous digit</span></span>
<span class="highlight-line">        <span class="token keyword">var</span> digit <span class="token operator">=</span> carry<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        <span class="token comment">// compute unsigned digit by summing up the corresponding bits</span></span>
<span class="highlight-line">        <span class="token keyword">var</span> powerof2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="highlight-line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>nbitsBg<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="highlight-line">            digit <span class="token operator">+=</span> powerof2 <span class="token operator">*</span> bits_in<span class="token punctuation">[</span>j <span class="token operator">+</span> i<span class="token operator">*</span>nbitsBg<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line">            powerof2 <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="highlight-line">        <span class="token punctuation">}</span></span>
<span class="highlight-line">        digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> digit<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        <span class="token comment">// carry = (digit > Bg/2) ? 1 : 0</span></span>
<span class="highlight-line">        bits_digit<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> <span class="token function">Num2Bits</span><span class="token punctuation">(</span>nbitsBg<span class="token punctuation">)</span><span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line">        carry <span class="token operator">=</span> <span class="token function">IsGtConstant</span><span class="token punctuation">(</span>Bg<span class="token operator">></span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">,</span> nbitsBg<span class="token punctuation">)</span><span class="token punctuation">(</span>bits_digit<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        <span class="token comment">// neg_digit = (digits[i] - Bg) mod Q</span></span>
<span class="highlight-line">        <span class="token keyword">var</span> neg_digit <span class="token operator">=</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> Bg <span class="token operator">+</span> Q<span class="token punctuation">;</span></span>
<span class="highlight-line"></span>
<span class="highlight-line">        <span class="token comment">// out[i] = (digit > Bg/2) ? neg_digit : digits[i]</span></span>
<span class="highlight-line">        out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token operator">=</span> carry<span class="token operator">*</span><span class="token punctuation">(</span>neg_digit <span class="token operator">-</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="highlight-line">    <span class="token punctuation">}</span></span>
<span class="highlight-line"><span class="token punctuation">}</span></span></code></pre><h2>Addressing other challenges</h2><p>As for addressing some of the other challenges that we faced, here is a list of solutions we found:</p><ul><li>Rounding. To compute $\lfloor x/q \rceil$, once we have obtained the quotient and remainder and constrained the division as $x = quot \cdot q + rem$, then we can use some comparison gadget to obtain the result computing</li></ul><p>$$\lfloor x/q \rceil = quot + (2\cdot rem &lt; q) ~ ? ~ 0 ~ : ~ 1$$</p><ul><li><p>Standard digit decomposition in different bases. Most of the parameter sets available for FHEW/TFHE used power-of-2 bases. By assuming so, we can leverage the binary decomposition from <code>Num2Bits</code> to obtain the digits for those larger bases.</p></li><li><p>Array access to indices unknown at compilation time. The idea is to perform a linear combination of all the elements of the array, where all the coefficients are 0 except the one corresponding to the element pointed by the index, which will be 1. We can use the <code>IsEqual</code> gadget from <code>circomlib</code> to assign the coefficients to the linear combination.</p></li><li><p>NTTs: we adapted the NTT implemented by <a href="https://github.com/microsoft/SEAL/blob/206648d0e4634e5c61dcf9370676630268290b59/native/src/seal/util/dwthandler.h#L202">SEAL</a>. We keep track of a bound on the size of the elements and only perform modular reductions right before they overflow the field modulus $p$.</p></li><li><p>Big RLWE-RGSW multiplication: we delay all the modular reductions until after all the sums and multiplications have been performed, as the sizes of the parameters allow one to do so. This results in a reduction of constraints by a factor of 10 compared to performing the modular reduction after each operation.</p></li></ul><p>In many situations, the challenge is not that much about figuring out how to arithmetize some particular operation, but rather about how to obtain the least number of constraints while doing so.</p><h2>Total constraints</h2><p>The arithmetization of all the operations of the schemes allowed us to obtain the full arithmetization of a bootstrapped NAND gate for both FHEW and TFHE schemes [repo]. Such operation is constructed on top of the functional bootstrapping of those schemes as explained in our previous blog post [previous blog post].</p><p>The Circom compiler can generate and optimize the number of R1CS constraints for a given circuit. However, the large parameters that those FHE schemes require for a level of 128 bits of security, and the memory requirements of Circom, make it quite challenging to compile the NAND gate circuit with the real parameters. By following a modular approach and understanding how constraints scale with the parameters, we were able to estimate the number of constraints generated for a bootstrapped NAND gate in each of the two FHE schemes:</p><ul><li>FHEW: 2.5 billion constraints.</li><li>TFHE: 1.5 billion constraints.</li></ul><p>Those numbers correspond to a single NAND gate, yes.</p><p>In order to understand where these constraints come from, we can break it down in terms of the more costly operations:</p><table><thead><tr><th>Operation</th><th>FHEW</th><th>TFHE</th></tr></thead><tbody><tr><td>NTT</td><td>73.01%</td><td>72.94%</td></tr><tr><td>Signed Decomposition</td><td>21.63%</td><td>18.01%</td></tr><tr><td>RLWE-RGSW multiplication</td><td>4.66%</td><td>7.90%</td></tr><tr><td>Key Switching</td><td>0.65%</td><td>1.08%</td></tr><tr><td>Accumulator Initialization</td><td>0.04%</td><td>0.07%</td></tr></tbody></table><p>As we can see, the NTTs are not only the bottlenecks in terms of the efficiency of the schemes, but also in terms of the number of constraints they generate. The second most costly operation is the signed decomposition we previously explained, as this operation is used a significant number of times and requires a couple of bit decompositions per operation. The third and last relevant operation is the multiplication between RLWE and RGSW ciphertexts, whose polynomials are assumed to be already sign-decomposed and in evaluation form.</p><p>Most of the constraints from the NTTs and RLWE-RGSW multiplications come from their modular reductions. Our approach is to perform a modular reduction right at the end of the NTT and at the end of the ciphertext multiplication, as well as intermediate reductions in the NTTs right before the elements overflow. While it can be seen from our modular reduction gadgets that reducing smaller integers is cheaper than reducing larger ones, it is generally cheaper to perform a single large reduction rather than many small ones. By keeping track of the sizes of the elements of the polynomials across different functions one could reduce the number of modular reductions to those strictly necessary before overflowing the field modulus. While that logic is not so simple to implement in a language like Circom, it is definitely something to consider to reduce the number of constraints further.</p><h2>Conclusion</h2><p>The arithmetization of a somewhat complex computation such as that of FHEW and TFHE schemes is not a trivial task, but one that poses several challenges as many operations can't be directly expressed in the form required for R1CS. Once we figured out a way to arithmetize each operation, an iterative process followed to reduce the number of constraints as much as possible while maintaining soundness.</p><p>While the resulting number of constraints that we have obtained is impractical for any real application, the breakdown per operation helps to identify the operations of FHEW and TFHE that require more effort to prove in zero knowledge. The significant number of constraints that come from emulating the FHE rings in the ZKP field (by applying modular reductions) hints at the need to develop proof systems tailored for the structure in which computations take place.</p><p>All the code from our arithmetization of FHEW and TFHE can be found here in our <a href="https://github.com/zkFHE/circomlib-fhe">circomlib-fhe repo</a>.</p></div><div class="bg-gray-400 mt-16 mb-4" style="height: 1px;"></div><div class="flex mb-4"><div><img class="h-16 object-center w-16 rounded-full m-auto object-cover" src="/images/people/students/Christian_Knabenhans.png" alt="Christian Knabenhans"></div><div class="flex flex-col ml-4 mt-1 text-gray-600"><div><a href="https://cknabs.github.io/" target="_blank" rel="noopener"><span>Christian Knabenhans</span></a></div><div class="flex flex-row mt">Published on&nbsp; <time datetime="Fri Oct 27 2023 00:00:00 GMT+0000 (Coordinated Universal Time)">27.10.2023</time><p class="px-2">â€”</p><div class="flex-col"><a href="https://github.com/zkFHE/circomlib-fhe" rel="noopener" aria-label="Github circomlib-FHE" target="_blank" style="display: inline-flex;"><svg style="margin-top: -2px;" class="fill-current" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="22" height="22" viewBox="0 0 22 22"><path d="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"></path></svg> <span class="ml-2">circomlib-FHE</span></a></div></div></div></div><div class="bg-gray-400" style="height: 1px;"></div><div class="mt-8 md:px-16"><div class="flex justify-between mt-16"><p class="text-gray-700 text-md"><span>Next:</span> <a href="/blog/fhew_tfhe/">A primer on the FHEW &amp; TFHE schemes</a></p></div></div></div></article></main><div class="footer-wrapper"><footer id="footer" class="footer"><div class="inner m-auto md:flex justify-between items-center py-10"><a href="https://ethz.ch" class="block text-gray-500 hover:text-pink-500" target="_blank" rel="noopener noreferrer"><span class="sr-only">ETH</span> <img src="https://pps-lab.com/images/logo/eth_logo_cropped.png" alt="ETH logo" class="h-10"></a></div></footer></div></div><nav id="mobile-nav" class="mobile-nav fixed left-0 top-0 h-screen w-full overflow-y-auto pt-12 bg-gray-200 z-50 md:hidden"><ul><li class="item relative opacity-0"><a href="/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Home</a></li><li class="item relative opacity-0"><a href="/people/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">People</a></li><li class="item relative opacity-0"><a href="/research/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Research</a></li><li class="item relative opacity-0"><a href="/publications/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Publications</a></li><li class="item relative opacity-0"><a href="/teaching/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Teaching</a></li><li class="item relative opacity-0"><a href="/funding/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Funding</a></li><li class="item relative opacity-0"><a href="/blog/" class="link block py-2 px-5 text-dark text-3xl hover:text-link-hover">Blog</a></li></ul></nav><button id="mobile-nav-toggle" class="mobile-nav-toggle block fixed h-16 w-full bottom-0 flex items-center justify-center font-bold border-none bg-gray-200 text-dark z-50 focus:outline-none md:hidden" aria-label="Mobile menu toggle" aria-expanded="false" aria-controls="mobile-nav"><span class="mobile-nav-label mr-2 font-medium">Menu</span> <span class="mobile-nav-icon" aria-hidden="true"><span class="mobile-nav-icon-line bg-black w-6 block transition-all duration-200 ease-out mb-1"></span> <span class="mobile-nav-icon-line bg-black w-6 block transition-all duration-200 ease-out mb-1"></span> <span class="mobile-nav-icon-line bg-black w-6 block transition-all duration-200 ease-out"></span></span></button><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true},
            jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
            extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
            TeX: {
            extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
            equationNumbers: {
            autoNumber: "AMS"
            }
          }
        });</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script></body></html>